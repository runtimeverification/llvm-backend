#!/bin/bash
set -e

usage() {
  cat << HERE
Usage: $0 <definition.kore> <dt_dir> <object type> [options] [clang flags]
   or: $0                            pythonast     [options] [clang flags]
   or: $0 <interpreter.o>            <object type> [options] [clang flags]

Options:
  -h, --help                Print this message and exit.
  -v, --verbose             Print commands executed to stderr.
  --save-temps              Do not delete temporary files on exit.
  --bindings-path           Print the absolute path of the compiled Python bindings for
                            the LLVM backend, then exit.
  --include-dir             Print the absolute include path for the LLVM backend
                            runtime and binding headers, then exit.
  --python PATH             The path to a Python interpreter with Pybind installed. Only
                            meaningful in "python" or "pythonast" mode.
  --python-output-dir PATH  Output directory to place automatically-named Python
                            modules. Only meaningful in "python" or "pythonast"
                            mode.

Any option not listed above will be passed through to clang; use '--' to
separate additional positional arguments to clang from those for $0.

Valid values for a KLLVM object type are:
  main:       a main function will be generated. The resulting executable has the
              signature "interpreter <input.kore> <depth> <output.kore>"

  library:    generate an interpreter with no main function linked.

  search:     as "main", but the resulting executable has collects all possible
              results at each rewrite step.

  static:     as "main", but do not link the resulting binary against the
              necessary shared libraries. This must be done manually later.

  python:     build a Python bindings module rather than a standalone executable.

  pythonast:  build a Python bindings module for the KORE AST structures only,
              without relying on a specific K definition.

  c:          build a C bindings module rather than a standalone executable.
HERE
}

run () {
  if [ "$verbose" = true ]; then
    set -x
  fi
  "$@"
  { set +x; } 2>/dev/null
}

print_bindings_path () {
  bin_dir="$(dirname "$0")"
  bindings_dir="$(realpath "$bin_dir/../lib/kllvm/python")"
  echo "$bindings_dir"
}

print_include_path () {
  bin_dir="$(dirname "$0")"
  include_dir="$(realpath "$bin_dir/../include")"
  echo "$include_dir"
}

llvm_major_version () {
  echo "@LLVM_PACKAGE_VERSION@" | cut -d'.' -f1
}

positional_args=()
reading_clang_args=false
kompile_clang_flags=()
clang_args=()
python_cmd=python3
python_output_dir=""

verbose=false
save_temps=false

while [[ $# -gt 0 ]]; do
  if [ "$reading_clang_args" = true ]; then
    clang_args+=("$1")
    shift
    continue
  fi

  case $1 in
    -h|--help)
      usage
      exit 0
      ;;
    -v|--verbose)
      verbose=true
      kompile_clang_flags+=("-v")
      shift
      ;;
    --save-temps)
      save_temps=true	    
      kompile_clang_flags+=("-save-temps")
      shift
      ;;
    --bindings-path)
      print_bindings_path
      exit 0
      ;;
    --include-dir)
      print_include_path
      exit 0
      ;;
    --python)
      python_cmd="$2"
      shift; shift
      ;;
    --python-output-dir)
      python_output_dir="$2"
      shift; shift
      ;;
    --)
      reading_clang_args=true
      shift
      ;;
    -*)
      kompile_clang_flags+=("$1")
      shift
      ;;
    *)
      positional_args+=("$1")
      shift
      ;;
  esac
done

if [[ "${#positional_args[@]}" -eq 1 && "${positional_args[0]}" != "pythonast" ]]; then
  usage
  exit 1
fi

if [[ "${#positional_args[@]}" -lt 1 || "${#positional_args[@]}" -gt 3 ]]; then
  usage
  exit 1
fi


mod="$(mktemp tmp.XXXXXXXXXX)"
modopt_tmp="$(mktemp tmp.XXXXXXXXXX)"
modopt="$modopt_tmp"
if [ "$save_temps" = false ]; then
  trap 'rm -rf "$mod" "$modopt_tmp"' INT TERM EXIT
fi

definition="${positional_args[0]}"
compile="default"
case "$definition" in
  *.o)
    compile="object"
    ;;
  pythonast)
    compile="python_ast"
    ;;
  *)
    ;;
esac

if [ "$compile" = "default" ]; then
  dt_dir="${positional_args[1]}"
  main="${positional_args[2]}"
  debug=0

  for arg in "${clang_args[@]}"; do
    case "$arg" in
      -g)
        debug=1
        ;;
      *)
        ;;
    esac
  done

  run "$(dirname "$0")"/llvm-kompile-codegen "$definition" "$dt_dir"/dt.yaml "$dt_dir" $debug > "$mod"

  if [ "$(llvm_major_version)" -ge "16" ]; then
    run @OPT@ -passes='mem2reg,tailcallelim' -tailcallopt "$mod" -o "$modopt"
  else
    run @OPT@ -mem2reg -tailcallelim -tailcallopt "$mod" -o "$modopt"
  fi
elif [ "$compile" = "object" ]; then
  main="${positional_args[1]}"
  modopt="$definition"
elif [ "$compile" = "python_ast" ]; then
  main="python_ast"
  modopt=""
fi

if [[ "$main" =~ "python" ]]; then
  bin_dir=$(dirname "$0")
  src_dir=$(realpath "$bin_dir/../lib/kllvm/python_src")

  if [[ "$compile" = "python_ast" ]]; then
    kompile_clang_flags+=("$src_dir/ast.cpp")
  else
    kompile_clang_flags+=("$src_dir/runtime.cpp")
  fi

  kompile_clang_flags+=("--python" "${python_cmd}")
fi

if [[ "$OSTYPE" != "darwin"* ]]; then
  kompile_clang_flags+=("-fuse-ld=lld")
fi

if [[ "${python_output_dir}" == "" ]]; then
  python_output_dir="$(dirname "${definition}")"
fi
kompile_clang_flags+=("--python-output-dir" "${python_output_dir}")

run "$(dirname "$0")"/llvm-kompile-clang          \
  "$modopt" "$main"                               \
  @LLVM_KOMPILE_LTO@ -fno-stack-protector         \
  "${kompile_clang_flags[@]}" "${clang_args[@]}"  \
